<!DOCTYPE html>
<html>
	
	<link rel="stylesheet" type="text/css" href="./stylesheets/week6_technical.css">

	<head>
		<title>Grace Yim | the blog</title>
	</head>

	<body>
		<div id="header">Grace Yim <span class="yim">the blog</span></div>

		<ul id="linkbar">
			<li><a href="http://graceekyim.github.io/index.html">Home</a></li>
			<li><a href="./aboutme.html">About Me</a></li>
			<li><a href="http://devbootcamp.com" target="_blank">Dev Bootcamp</em></a></li>
		</ul>

		<div id="post1">
			<p class="date1">Thursday, June 19, 2014</p>

			<h1 id="head1"><span id="subheader">Technical Blog 2.6</span><br/>Ruby Blocks, Procs and Lambdas</h1>			
			
			
			<p class="text">

				When you're coding in Ruby, you will occasionally need to reuse a block of code. Unfortunately, blocks can only be "reused" by copying the code. This is where procs and lambdas can help. Procs and lambdas are basically blocks of code that are saved as objects so they can be reused within a program. <br/><br/>

				Today we're going to review the differences among blocks, procs and lambdas so you can determine how to use them in your code. To start, here's a comparison of these three features:<br/>


				<table>
					<tr>
						<th></th>
						<th scope = "column">Is it<br/>an object?</th>
						<th scope = "column">Structure</th>
						<th scope = "column">Can it be<br/>reused?</th>
						<th scope = "column">Checks number of<br/>arguments?</th>
						<th scope = "column">Returns to<br/>calling method?</th>
					</tr>
					<tr>
						<th scope = "row" id = "rightalign">Blocks</th>
						<td>Nope</td>
						<td>Contained within <em>{...}</em><br/>or <em>do...end</em> syntax</td>
						<td>Nope,<br/>single use only</td>
						<td>N/A</td>
						<td>N/A</td>
					</tr>
					<tr>
						<th scope = "row" id = "rightalign">Procs</th>
						<td>Yep,<br/>a Proc object</td>
						<td><em>Proc.new {block}*</em></td>
						<td>Yep</td>
						<td>Nope</td>
						<td>Nope,<br/> stops at <em>return</em> and<br/>returns value</td>
					</tr>
					<tr>
						<th scope = "row" id = "rightalign">Lambdas</th>
						<td>Yep,<br/>a Proc object</td>
						<td><em>lambda {|param| block}*</em></td>
						<td>Yep</td>
						<td>Yep</td>
						<td>Yep, returns value<br/>and continues method</td>
					</tr>
					<tr>
						<td id = "leftalign"></td>
						<td colspan = 6 id = "leftalign"><em>*There are other structures for procs and lambdas, but these are the most common</em></td>
					</tr>

				</table><br/>

				<hr>

				<h2>Blocks</h2>

				Blocks are sections of code contained within curly braces, <em>{...}</em>, or <em>do...end</em> syntax. Here's an example of a block:<br/><br/>

				Block Example:<br/>

				<img src = "./images/week6_technical/block_example.png" alt="Block Example" class = "block_ex"><br/><br/>

				Block Result:<br/>

				<img src = "./images/week6_technical/block_result.png" alt="Result" class = "result"><br/><br/>

				In this example, the block is contained within the <em>do...end</em> syntax. On line 1, the block was combined with the <em>each</em> method to iterate through an array (["a","b","c"]). <br/><br/>

				You can see in the result that this block printed out each letter in the array.<br/><br/>

				If you wanted to run the block on another array, you would need to copy the entire block. If you wanted to save the block as an object, procs and lambdas would provide a good solution. They are especially helpful when you anticipate you'll be using a block of code more than once in a program. <br/><br/>

				Let's start by reviewing procs...<br/><br/>

				<hr>
			
				<h2>Procs</h2>
				
				Procs, or procedures, basically allow you to create a Proc object from a block. This gives you the flexibility to reuse the code. Let's take the block above and make it a proc.<br/><br/>

				Proc Example 1:<br/>

				<img src = "./images/week6_technical/proc_example1.png" alt="Proc Example 1" class="proc_ex1"><br/><br/>

				Proc Result 1:<br/>

				<img src = "./images/week6_technical/block_result.png" alt="Result" class = "result"><br/><br/>

				In line 1 of the code, you'll see that we created a new Proc object, using the <em>Proc.new {...}</em> syntax, named proc_letter that contains the block. In line 2, we combined the Proc object with the <em>each</em> method, just like we did with the original block. The <em>&</em> was added to turn the proc into a block since the <em>each</em> method expects a block. <br/><br/>

				You can see in the result that this proc printed out each letter in the array, just like the original block.<br/><br/>

				<hr>

				<h3>Procs & Arguments</h3>

				Now that we've seen an example of a proc, let's take a look at how it handles arguments. When a proc is called, it does not check the number of arguments it receives. If there are more arguments than needed, the proc will just execute the number of arguments it expected. Let's look at an example:<br/><br/>

				Proc Example 2:<br/>

				<img src = "./images/week6_technical/proc_example2.png" alt = "Proc Example 2" class = "proc_ex2"><br/><br/>

				Proc Result 2:<br/>

				<img src = "./images/week6_technical/proc_result2.png" alt = "Proc Result 2" class = "proc_result2"><br/><br/>


				First, you'll notice that we tweaked proc_letter so that it will <em>puts</em> the letter instead of <em>return</em>. We added the <em>puts</em> to ensure the letter was being printed since we did not use the <em>each</em> method in this example. This brings us to the second change: in order to show you how procs handle arguments, we used the <em>call</em> method to run proc_letter. Again, this is just a different way of running the proc in order to show you how it handles arguments.<br/><br/>

				Now let's look at what happened when we ran the code. In line 2 of the code, the Proc object was called using the <em>call</em> method and two arguments were passed in: letters "k" and "t". Looking at the result, we see that only letter "k" was printed. Since the block of code in proc_letter only expected one argument, it ignored letter "t". This shows how procs ignore arguments when executing a block of code.<br/><br/>

				<hr>

				<h3>Procs & <em>return</em> Statements</h3>


				Another characteristic of a proc is that it stops at a <em>return</em> statement and immediately returns a value without going back to the method that called it. Let's take a look at how this works:<br/><br/>

				Proc Example 3:<br/>

				<img src = "./images/week6_technical/proc_example3.png" alt = "Proc Example 3" class = "proc_ex3"><br/><br/>

				Proc Result 3:<br/>

				<img src = "./images/week6_technical/proc_result3.png" alt = "Proc Result 3" class = "proc_result3"><br/><br/>

				In example 3, we took Proc Example 2 and placed the Proc object in a new method called <em>test</em>. We changed <em>puts</em> back to <em>return</em> since we are testing how procs handle the <em>return</em> statement. In line 3, we called proc_letter by using the <em>call</em> method and passed in the letter "k". In line 4, we told the method to <em>puts</em> "I printed the last line". Then in line 7, we called the <em>test</em> method to see what would happen.<br/><br/> 

				In the result, you'll see that we ran the Ruby file, but it did not <em>puts</em> "I printed the last line". Here's what happened: When the <em>test</em> method started running, it called proc_letter in line 3 and started executing line 2. When the proc ran into the return statement in line 2, it returned the letter "k" and then stopped. Line 4 was never executed since procs stop after they encounter <em>return</em> statements. <br/><br/>

				Now that we've seen how procs work, let's take a look at how lambdas differ from procs...<br/><br/>

				<hr>

				<h2>Lambdas</h2>

				Lambdas are Proc objects, just like procs and they allow you to save and reuse a block of code. Let's take Proc Example 1 and make it into a lambda:<br/><br/>

				Lambda Example 1:<br/>

				<img src = "./images/week6_technical/lambda_example1.png" alt = "Lambda Example 1" class = "lambda_ex1"><br/><br/>

				Lambda Result 1:<br/>

				<img src = "./images/week6_technical/block_result.png" alt = "Lambda Result 1" class = "result"><br/><br/>

				The block contained within lambda_letter is the same as the block contained within Proc Example 1 and the only difference is the syntax: lambda <em>{...}</em>. As for the result, it's the same as the result from Block Example and Proc Example 1.<br/><br/>

				As you probably noticed in the comparison table, the main differences between lambdas and procs are the ways they handle arguments and methods.<br/><br/>

				<hr>

				<h3>Lambdas & Arguments</h3>

				Let's take a look at how lambdas check arguments by creating a lambda that contains the same block as Proc Example 2:<br/><br/>

				Lambda Example 2:<br/>

				<img src = "./images/week6_technical/lambda_example2.png" alt = "Lambda Example 2" class = "lambda_ex2"><br/><br/>

				Lambda Result 2:<br/>

				<img src = "./images/week6_technical/lambda_result2.png" alt = "Lambda Result 2" class = "lambda_result2"><br/><br/>

				Once again, the block contained within lambda_letter is the same as the block contained within Proc Example 2 and the only difference is the syntax: lambda <em>{...}</em>. <br/><br/>

				In line 2, lambda_letter was called using the <em>call</em> method and two arguments were passed in: letters "k" and "t". Unlike procs, lambdas check arguments. Since the block of code in lambda_letter only expected one argument and it received two, it raised an argument error, as you can see in Lambda Result 2. <br/><br/>

				<hr>

				<h3>Lambdas & <em>return</em> Statements</h3>

				Now let's see how the <em>test</em> method would look if we used a lambda by creating a lambda that contains the same block as Proc Example 3: <br/><br/>

				Lambda Example 3:<br/>

				<img src = "./images/week6_technical/lambda_example3.png" alt = "Lambda Example 3" class = "lambda_ex3"><br/><br/>

				Lambda Result 3:<br/>

				<img src = "./images/week6_technical/lambda_result3.png" alt = "Lambda Result 3" class = "lambda_result3"><br/><br/>

				In line 2, the block contained within lambda_letter is the same as the block contained within Proc Example 3 and the only difference is the syntax: lambda <em>{...}</em>. <br/><br/>

				In the result, you'll see that the code <em>puts</em> "I printed the last line". Here's what happened: When the <em>test</em> method started running, it called lambda_letter in line 3 and started executing line 2. When the lambda ran into the return statement in line 2, it returned the letter "k". Unlike the proc, the lambda did not stop there. It continued through the rest of the method and executed line 4, printing "I printed the last line". <br/><br/>

				<hr>

				<h2>Summary</h2>

				Now that you understand the differences among blocks, procs and lambdas, you should have a good idea of how to use them in your own code. Try using a proc or lambda in your next program!<br/><br/>

				For more information on procs and lambdas, check out one of the following sites:  

				<ul>
					<li><a href="http://www.reactive.io/tips/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/" id = "resources" target="_blank">Reactive.TIPS</a></li>
					<li><a href="http://www.ruby-doc.org/core-1.9.3/Proc.html" id = "resources" target="_blank">Ruby-Doc</a></li>
					<li><a href="http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/64-blocks-procs-lambdas" id = "resources" target="_blank">RubyMonk</a></li>
				</ul>




			</p>

			
		</div>

		<div id="footer">Grace Yim <span class="footer">the blog</span></div>

</html>
